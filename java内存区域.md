## 一、Java内存区域(运行时数据区域)

> 线程私有的区域：程序计数器，Java虚拟机栈，本地方法栈。
>
> 线程共享的区域：Java堆、方法区、直接内存(不属于运行时数据区域).

### 1.1 程序计数器

> 是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是根据这个计数器的值来选择下一条需要执行的命令。

* java的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，因此对于每个线程都有一个独立的计数器，保证再次切回线程时可以恢复到之前正确的执行位置，这类内存区域被称为“线程私有”的内存。
* 每个线程的程序计数器互不影响、独立存储。
* 如果线程执行的是java方法，那么计数器的值就为当前正在执行的虚拟机字节码指令的地址。
* 如果线程执行的是native方法，那么计数器的值就为空(Undefined)。
* 该内存区域是唯一一个在java虚拟机规范中没有规定`OutOfMemoryError`情况的区域。

### 1.2 Java虚拟机栈

* 生命周期和线程是相同的，也是线程私有的，随着线程的消亡而消亡。
* 描述了Java方法执行的内存模型，每个方法的执行过程就是一个栈帧从入栈到出栈的过程(栈帧是用来存储每个方法的局部变量表、操作数栈、动态链接、出口信息等)。
  * 局部变量表包括编译器可知的各种基本数据类型、对象引用、returnAddress(执行一条字节码指令的地址)。
  * long和double类型需要占用两个局部变量空间(Slot)，其他类型只需要占用一个。
  * 局部变量表需要的内存空间是在编译时期完成的，在方法运行期间不会改变。
* 该区域规定了两种异常情况：
  * 如果线程请求的栈深度超过了虚拟机栈允许的深度，就会抛出StackOverflowError异常。
  * 如果虚拟机栈支持动态扩展，在扩展之后依然无法申请到足够的内存，就会抛出OutOfMemoryError异常。
* java的两种方法方式：return语句和抛出异常，两种方式都会导致对应方法的栈帧被弹出

### 1.3  本地方法栈

> 和Java虚拟机栈基本相同，不过Java虚拟机栈执行的是Java方法(字节码)，而本地方法栈指定的是`Native`方法。

* 在Sun HotSpot虚拟机中直接将Java虚拟机栈和本地方法栈合并在一起了。
* 本地方法栈的异常抛出情况和Java虚拟栈的异常情况一致。

### 1.4 Java方法堆

> Java方法堆几乎是内存区域中最大的一块，主要用于存放对象的实例，几乎所有的对象实例和数组都在这里分配。

* **Java堆是被所有线程共享的内存区域，在虚拟机启动时创建。**

* Java堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。

* 为了更好的回收内存和分配内存，主要从以下两个角度划分：
  * 内存回收：基于分代收集算法划分为(新生代和老年代)或者(`Eden`空间, `From Surviore`空间、`To Survior`空间)。
  * 内存分配：可能划分出多个线程私有的分配缓冲区(TLAB).
  
* 大部分情况下，对象会首先在`Eden`区域进行分配，在经历一次垃圾回收后，如果对象没有被回收，就会进入`Survivor(s0/s1)`区域，并且对象的年龄会加1，当它的年龄上升到一定程度后就会进入老年代(默认是15岁)，对象晋升到了老年代的阈值，该参数可以通过`-XX:MaxTenuringThresold`来设置。

* Hotspot会遍历所有对象时会根据年龄从小到大进行累积，当累积的某个年龄大小超过了`Survivor`区的一半，就会去该年龄和`MaxTenuringThresold`值的小值作为新的晋升年龄阈值。

* Java堆可以处于物理上不连续的存储空间，只要逻辑上连续即可。

* 可以实现为固定大小或者可扩展的(通过-Xmx和-Xms控制)。

* 如果堆的内存无法完成实例分配，并且无法扩展，就会抛出`OutOfMemoryError`异常。

  > 堆溢出抛出的异常：`java.lang.OutOfMemoryError: Java heap space`

### 1. 5 方法区

> 类似与Java堆，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的的代码等数据。

* 可以选择不实现垃圾收集，但是并不表示该区域的数据就是永久存在的。
* 该区域的内存回收主要针对于常量池的回收和对类型的卸载，不过效率较低。

* 当方法区无法满足内存分配需求时，就会抛出`OutOfMemoryError`异常。
* 永久代和元空间都是它的一种实现方式，JDK1.8之后使用元空间代替了永久代，元空间使用的是直接内存。

### 1.6  运行时常量池

> 是属于方法区的一部分，Class文件除了类的版本、字段、接口等信息外，还有常量池用于存放编译器生成的各种字面量和符号引用，在类加载之后进入到方法区的运行时常量池中存放。

* 具备动态性，除了编译时期的常量之外，在运行期间的常量也可以进入该区域，如`String.intern()`方法。
* 如果常量池无法在申请到新的内存，就会抛出`OutOfMemoryError`异常。
* 在JDK1.7中，字符串常量池被移到了Java堆中，当时运行时常量池其他的内容依然还在方法区中。
* 在JDK1.8中，Hotspot移除了永久代，使用元空间对其取而代之，当时字符串常量池还在堆中，运行时常量池在方法区中。

### 1.7 堆和栈的区别

* 栈内存存储局部变量，堆内存存储实体。
* 栈内存的更新速度要远大于堆内存，因为局部变量的生命周期较短。
* 栈内存的局部变量只要生命周期结束就会被回收，而堆内存的实体则会被垃圾收集器不定时回收。

### 1. 8 直接内存

> 不是属于虚拟机运行时数据区的一部分，也可能导致`OutOfMemoryError`异常。

* 在JDK1.4中新加入的NIO类引入了一种基于通道和缓存区的I/O方式，可以直接使用Native函数分配堆外内存，然后通过在Java堆中的`DirectByteBuffer`对象作为对该块内存的引用进行操作。从而避免了在Java堆和native之间反复的赋值数据。

### 1.9 常见问题

#### 1.9.1 为什么要将永久代替换为元空间？

* 1、整个永久代有一个JVM本身设置的固定上限，无法进行调整，而元空间使用的是直接内存，取决于系统本身的内存限制，虽然元空间依然会可能会溢出，但是溢出的几率就大大减小了，可以通过`-XX:MetaspaceSize=N`设置`Metaspace`的初始大小,`-XX:MaxMetaspaceSize=N`设置`Metaspace`的最大值，如果没有指定元空间的大小，则`Metaspace`就根据程序动态的调整。

  > 元空间溢出的异常：`java.lang.OutOfMemoryError: MetaSpace`

* 2、元空间存放的是类的元数据，这样加载的元数据的数量就不由`MaxPermsize`参数控制，而是直接有系统可用的内存来决定，从而可以加载更多的类。

* 3、在JDK1.8中，Hotspot和JRockit合并时，在JRockit中没有永久代，因此没有必要额外设置一个永久代。

## 二、虚拟机对象

### 2.1  对象的创建过程

#### 2.1.1 类加载检查

虚拟机遇到一条new指令后，首先检查这条指令的参数能否在常量池中定位到这个类的符号引用，并检查这个类的符号引用是否被加载过、解析和 初始化过、如果没有，就需要执行相应的类加载过程。

#### 2.1.2 分配内存

在类加载检查通过后，就开始为新生对象分配内存，而对象所需的内存大小在类加载完成后就已经确定，为对象分配内存将等于将一块确定大小的内存从Java堆中划分出来，分配方式有“指针碰撞”和“空闲列表“两种，具体采用哪种分配方式取决于java堆是否规整，而java堆是否规整则取决于采用的垃圾收集器是否具有压缩整理功能而决定。

#####  内存分配的两种方式

* 使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞。
* 使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。
* 内存分配图示：![内存分配的两种方式](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/内存分配的两种方式.png)

##### 内存分配并发问题

* 1、CAS + 失败重试：乐观锁是每次不加锁而是假设没有冲突去执行某项操作，如果发生冲突就重试，直到成功为止。虚拟机采用CAS和失败重试的方法去保证更新操作的原子性。
* 2、TLAB：把内存分配的动作按照线程划分在不同的空间中执行，即每个线程预先在Eden区分配一块内存作为本地线程分配缓冲(TLAB，可以通过`-XX:+/-UseTLAB`参数设置)，JVM在给对象分配内存时，首先在TLAB上分配，如果TLAB的内存不足以分配或者TLAB的内存已经用尽，就会采用方式一进行内存分配。

#### 2.1.3 初始化零值

* 内存分配完成后，虚拟机需要对这些分配到的内存空间都初始化为零值(不包含对象头)

* 如果使用TLAB，这一步可以提前到TLAB分配时进行。
* 这一步是为了保证对象的实例字段在Java代码中不用赋初始值就可以直接使用，程序可以访问这些字段的数据类型所对应的零值。

#### 2.1.4 设置对象头

* 初始零值完成后，虚拟机需要对对象进行必要的设置，如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，这些信息都保存在对象头中。
* 另外，根据虚拟机的运行状态的不同，是否使用偏向锁等，对象头都会有不同的设置。

#### 2.1.5  执行`init`方法

在执行上述方法之后，从虚拟机视角来看，一个新的对象已经产生了，但从java程序的角度来看，对象的创建才刚刚开始，`init`方法还没有执行，所有的字段都还为零值，因此一般来说(由字节码中是否跟随invokespecial指令所决定的)，在执行`new`指令之后还会执行`init`方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算创建完成。

### 2.2 对象的内存布局

> 在HotSpot中，对象在内存中的布局分为三个区域：对象头、实例数据、对齐补充，以下说明均针对于HotSpot

* 对象头：一部分由于存储对象自身的运行时数据(如哈希码、GC分代年龄、锁状态信息等)，另一部分存储类型指针，即对象指向它的类元数据的指针，虚拟机用这个指针来确定这个对象是属于那个类的实例。
* 实例数据：用于存储对象真正存储的有效信息，即程序中所定义的各种字段的内容。
* 对齐补充：该部分不是一定存在，取决于实例数据部分的字节数是否为8的倍数，如果不是，就需要对齐补充，因为HotSpot要求对象的起始地址必须是8的倍数，而对象头的字节数是8的倍数(1/2倍)，因此实例数据和对齐补充的字节数要为8的倍数。

### 2.3 对象的访问定位

> java程序通过栈上的reference数据来访问java堆上的具体对象，目前主流的访问方式有通过句柄访问和直接指针访问两种。

#### 2.3.1 通过句柄访问

* 如果通过句柄访问，那么java堆中就会划分出一块内存作为句柄池，`reference`存储的是句柄的地址，句柄存储的是对象的实例数据和类型数据各自的具体地址信息。如下图所示：

  ![通过句柄访问](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/对象的访问定位-使用句柄.png)

#### 2.3.2通过直接指针访问

* 如果使用直接指针访问，那么java堆的对象布局中就必须考虑如何放置访问类型数据的相关信息，而`reference`中存储的就是直接的对象地址。

  ![通过指针访问](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/对象的访问定位-直接指针.png)

### 2.4 补充内容

#### 2.4.1 String类和常量池

* String对象的两种创建方式：
  * 1、在常量池中拿对象，如果常量池没有，就会先创建一个，然后在取。
  * 2、直接在堆内存空间创建一个新的对象
* String类型的常量池的使用方法
  * 1、直接使用双引号声明的String对象会直接存储在常量池中。
  * 2、如果不是使用双引号声明的String对象，可以使用String.intern()方法，该方法是一个本地方法，如果运行时常量池中存在一个等于String内容的字符串，就会直接返回在常量池中该字符串的引用，如果常量池中没有该字符串，在JDK1.7之前，会先在常量池中创建一个与此String内容相同的字符串，并返回常量池中字符串的引用，在JDK1.8之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。
* String类的注意点
  * 1、String的拼接：尽量避免多个字符串的拼接，因为这样会重新创建新的对象，如果需要改变字符串，可以使用StringBuilder或者StringBuffer。
  * 2、String类设置为不可变主要是为了保证效率和安全，可以提高字符串常量池的效率和安全，并且可以提高拷贝的效率，只用拷贝该对象的指针即可，另外不可变对于多线程来说是安全的。
  * 3、`String s1 = new String("abc");`，如果常量池中没有`abc`常量，就会现在常量池中创建一个常量对象，然后再在堆中创建一个对象。

#### 2.4.2 8种基本类型的包装类和常量池

> Java基本类型的大部分都实现了常量池技术，即Byte、Short, Integer, Long, Character, Boolean，前四种包装类默认创建了[-128, 127]的相应类型的缓存数据，Character则缓存了数值在[0, 127]之间的数据，Boolean则直接返回true or false,如果超出了就会去创建新的对象。但是Float和Double两种包装了没有实现常量池技术。

* 1、为什么区间是设置为[-128, 127]?

  是为了资源和性能的的平衡。 

